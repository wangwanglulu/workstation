<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Lecture 16</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../dist/reset.css">
    <link rel="stylesheet" href="../dist/reveal.css">
    <link rel="stylesheet" href="../dist/theme/white.css" id="theme">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../plugin/highlight/github.css">
    <link rel="stylesheet" href="../plugin/chalkboard/style.css">
    <link rel="stylesheet" href="../plugin/customcontrols/style.css">
    <link rel="stylesheet" href="../plugin/menu/font-awesome/css/all.css">
</head>

<body>
    <div class="reveal" style="background-color: #fff;">
        <div class="slides">
             <section data-background-iframe="../particles/demo/index.html" style="text-align: left;">
                <div style="position: absolute; width: 60%; left: 0; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.6); color: #fff; padding: 20px; font-size: 20px; text-align: left;">
                         <h1 style="color: white">Python Programming</h1>
                <h3 style="color: white">Lecture 16 Basic Data Structure</h3>
                    </div>
            </section>
            <section>
                <section data-background="#2980b9" style="color: white">
                    <h2 style="color: white">16.1 Stacks</h2>
                </section>
                <section>
                    <h5>Linear Structures</h5>
                    <ul>
                        <li class="fragment">Stacks queues, deques, and lists are examples of data collections whose items are ordered depending on how they are added or removed.</li>
                        <li class="fragment">Once an item is added, it stays in that position relative to the other elements that came before and came after it. Collections such as these are often referred to as <b>linear data structures</b>.</li>
                    </ul>
                </section>
                <section>
                    <h5>Stacks (栈)</h5>
                    <ul>
                        <li class="fragment">A stack is an ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end.</li>
                        <li class="fragment">This ordering principle is sometimes called <b>LIFO, last-in first-out</b>.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/stack1.png" style="height: 150pt"></div>
                    <div class="fragment"><img data-src="../img/lecture18/stack2.png" style="height: 200pt"></div>
                </section>
                <section>
                    <h5>The Stack Abstract Data Type</h5>
                    <ul>
                        <li class="fragment"> The stack abstract data type is defined by the following structure and operations. </li>
                        <li class="fragment"> <b>Stack()</b> creates a new stack that is empty. It needs no parameters and returns an empty stack.</li>
                        <li class="fragment"><b>push(item)</b> adds a new item to the top of the stack. It needs the item and returns nothing.</li>
                        <li class="fragment"><b>pop()</b> removes the top item from the stack. It needs no parameters and returns the item. The stack is modified.</li>
                        <li class="fragment"><b>peek()</b> returns the top item from the stack but does not remove it. It needs no parameters. The stack is not modified.</li>
                        <li class="fragment"><b>is_empty()</b> tests to see whether the stack is empty. It needs no parameters and returns a boolean value.</li>
                        <li class="fragment"><b>size()</b> returns the number of items on the stack. It needs no parameters and returns an integer.</li>
                    </ul>
                </section>
                <section>
                    <h5>Implementing a Stack in Python</h5>
                    <ul>
                        <li class="fragment">To implement a stack, which is a collection of elements, it makes sense to utilize the power and simplicity of the primitive collections provided by Python. We will use a list.</li>
                    </ul>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
class Stack:
     def __init__(self):
         self.items = []

     def isEmpty(self):
         return self.items == []

     def push(self, item):
         self.items.append(item)

     def pop(self):
         return self.items.pop()

     def peek(self):
         return self.items[len(self.items)-1]

     def size(self):
         return len(self.items)
</code></pre>
                    </div>
                </section>
                <section data-background-image="../bg.png">
                    <div class='div-c'>
                        <div class="fragment">
                            <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
class Stack:
    def __init__(self):
        self.items = []
    def isEmpty(self):
        return self.items == []
    def push(self, item):
        self.items.append(item)
    def pop(self):
        return self.items.pop()
    def peek(self):
        i = len(self.items)-1
        return self.items[i]
    def size(self):
        return len(self.items)
</code></pre>
                        </div>
                    </div>
                    <div class='div-d'>
                        <div class="fragment">
                            <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
s=Stack()

print(s.isEmpty())
s.push(4)
s.push('dog')
print(s.peek())
s.push(True)
print(s.size())
print(s.isEmpty())
s.push(8.4)
print(s.pop())
print(s.pop())
print(s.size())
</code></pre>
                        </div>
                        <div class="fragment">
                            <pre><code class="output" data-trim contenteditable>
True
dog
3
False
8.4
True
2
</code></pre>
                        </div>
                    </div>
                </section>
                <section>
                    <h5>Simple Balanced Parentheses</h5>
                    <ul>
                        <li class="fragment">Parentheses must appear in a balanced fashion. Balanced parentheses means that each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested. Consider the following correctly balanced strings of parentheses:</li>
                    </ul>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
(()()()())
(((())))
(()((())()))
</code></pre>
                    </div>
                    <ul>
                        <li class="fragment">Compare those with the following, which are not balanced:</li>
                    </ul>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
((((((())
()))
(()()(()
</code></pre>
                    </div>
                </section>
                <section>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def parChecker(symbolString):
    s = Stack()
    balanced = True
    index = 0
    while index < len(symbolString) and balanced:
        symbol = symbolString[index]
        if symbol == "(":
            s.push(symbol)
        else:
            if s.isEmpty():
                balanced = False
            else:
                s.pop()
        index = index + 1

    if balanced and s.isEmpty():
        return True
    else:
        return False
</code></pre>
                    </div>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
print(parChecker('((()))'))
print(parChecker('(()'))
</code></pre>
                    </div>
                </section>
            </section>
            <section>
                <section data-background="#2980b9" style="color: white">
                    <h2 style="color: white">16.2 Queues and Deques</h2>
                </section>
                <section>
                    <h5>Queues (队列)</h5>
                    <ul>
                        <li class="fragment">A queue is an ordered collection of items where the addition of new items happens at one end</li>
                        <li class="fragment">The most recently added item in the queue must wait at the end of the collection. The item that has been in the collection the longest is at the front. This ordering principle is sometimes called <b>FIFO, first-in first-out</b>.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/queue1.png" style="height: 180pt"></div>
                </section>
                <section>
                    <h5>The Queue Abstract Data Type</h5>
                    <ul>
                        <li class="fragment"><b>Queue()</b> creates a new queue that is empty. It needs no parameters and returns an empty queue.</li>
                        <li class="fragment"><b>enqueue(item)</b> adds a new item to the rear of the queue. It needs the item and returns nothing</li>
                        <li class="fragment"><b>dequeue()</b> removes the front item from the queue. It needs no parameters and returns the item. The queue is modified.</li>
                        <li class="fragment"><b>is_empty()</b> tests to see whether the queue is empty. It needs no parameters and returns a boolean value.</li>
                        <li class="fragment"><b>size()</b> returns the number of items in the queue. It needs no parameters and returns an integer.</li>
                    </ul>
                </section>
                <section data-background-image="../bg.png">
                    <div class='div-c'>
                        <div class="fragment">
                            <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
class Queue:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def enqueue(self, item):
        self.items.insert(0,item)

    def dequeue(self):
        return self.items.pop()

    def size(self):
        return len(self.items)
</code></pre>
                        </div>
                    </div>
                    <div class='div-d'>
                        <div class="fragment">
                            <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
>>> q.size()
3
>>> q.isEmpty()
False
>>> q.enqueue(8.4)
>>> q.dequeue()
4
>>> q.dequeue()
'dog'
>>> q.size()
2
</code></pre>
                        </div>
                    </div>
                </section>
                <section>
                    <h5>Simulation: Hot Potato</h5>
                    <ul>
                        <li class="fragment">One of the typical applications for showing a queue in action is to simulate a real situation that requires data to be managed in a FIFO manner.</li>
                        <li class="fragment">To begin, let's consider the children's game Hot Potato.</li>
                        <li class="fragment">This game is a modern-day equivalent of the famous Josephus problem. Based on a legend about the famous first-century historian Flavius Josephus, the story is told that in the Jewish revolt against Rome, Josephus and 39 of his comrades held out against the Romans in a cave. With defeat imminent, they decided that they would rather die than be slaves to the Romans. They arranged themselves in a circle. One man was designated as number one, and proceeding clockwise they killed every seventh man.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li class="fragment">We will implement a general simulation of Hot Potato. Our program will input a list of names and a constant, call it "num" to be used for counting. It will return the name of the last person remaining after repetitive counting by num.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/hot1.png" style="height: 200pt"></div>
                    <div class="fragment"><img data-src="../img/lecture18/hot2.png" style="height: 200pt"></div>
                </section>
                <section>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def hotPotato(namelist, num):
    simqueue = Queue()
    for name in namelist:
        simqueue.enqueue(name)

    while simqueue.size() > 1:
        for i in range(num):
            simqueue.enqueue(simqueue.dequeue())

        simqueue.dequeue()

    return simqueue.dequeue()

print(hotPotato(["Bill","David","Susan","Jane","Kent","Brad"],7))
</code></pre>
                    </div>
                </section>
                <section>
                    <h5>Deques (双端队列, <b>not dequeue!</b>)</h5>
                    <ul>
                        <li class="fragment">A deque, also known as a double-ended queue, is an ordered collection of items similar to the queue.</li>
                        <li class="fragment">What makes a deque different is the unrestrictive nature of adding and removing items. New items can be added at either the front or the rear. Likewise, existing items can be removed from either end.</li>
                        <li class="fragment">It is important to note that even though the deque can assume many of the characteristics of stacks and queues, it does not require the LIFO and FIFO orderings that are enforced by those data structures. It is up to you to make consistent use of the addition and removal operations.</li>
                    </ul>
                </section>
                <section>
                    <h5>The Queue Abstract Data Type</h5>
                    <ul>
                        <li class="fragment"><b>Deque()</b> creates a new deque that is empty. It needs no parameters and returns an empty deque.</li>
                        <li class="fragment"><b>add_front(item)</b> adds a new item to the front of the deque. It needs the item and returns nothing.</li>
                        <li class="fragment"><b>add_rear(item)</b> adds a new item to the rear of the deque. It needs the item and returns nothing.</li>
                        <li class="fragment"><b>remove_front()</b> removes the front item from the deque. It needs no parameters and returns the item. The deque is modified.</li>
                        <li class="fragment"><b>remove_rear()</b> removes the rear item from the deque. It needs no parameters and returns the item. The deque is modified.</li>
                        <li class="fragment"><b>is_empty()</b> tests to see whether the deque is empty. It needs no parameters and returns a boolean value.</li>
                        <li class="fragment"><b>size()</b> returns the number of items in the deque. It needs no parameters and returns an integer.</li>
                    </ul>
                </section>
                <section>
                    <h5>Implementing a Deque in Python</h5>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
class Deque:
    def __init__(self):
        self.items = []
    def isEmpty(self):
        return self.items == []

    def addFront(self, item):
        self.items.append(item)

    def addRear(self, item):
        self.items.insert(0,item)

    def removeFront(self):
        return self.items.pop()

    def removeRear(self):
        return self.items.pop(0)
    def size(self):
        return len(self.items)
</code></pre>
                    </div>
                </section>
            </section>
            <section>
                <section data-background="#2c3e50" style="color: white; text-align: left;">
                    <h2 style="color: white">Summary</h2>
                    <ul>
                        <li>Stacks</li>
                        <li>Queues</li>
                        <li>Deques</li>
                    </ul>
                </section>
            </section>
        </div>
    </div>
    <script src="../dist/reveal.js"></script>
    <script src="../plugin/zoom/zoom.js"></script>
    <script src="../plugin/notes/notes.js"></script>
    <script src="../plugin/search/search.js"></script>
    <script src="../plugin/markdown/markdown.js"></script>
    <script src="../plugin/highlight/highlight.js"></script>
    <script src="../plugin/math/math.js"></script>
    <script src="../plugin/zoom_old/zoom_old.js"></script>
    <script src="../plugin/chalkboard/plugin.js"></script>
    <script src="../plugin/customcontrols/plugin.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js"></script>
    <script src="../plugin/copycode/copycode.js"></script>
    <script src="../plugin/pdfexport/pdfexport.js"></script>
    <script>
    // Also available as an ES module, see:
    // https://revealjs.com/initialization/
    Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,
        customcontrols: {
            controls: [{
                    id: 'toggle-overview',
                    title: 'Toggle overview (O)',
                    icon: '<i class="fa fa-th"></i>',
                    action: 'Reveal.toggleOverview();'
                },
                {
                    icon: '<i class="fa fa-pen-square"></i>',
                    title: 'Toggle chalkboard (B)',
                    action: 'RevealChalkboard.toggleChalkboard();'
                },
                {
                    icon: '<i class="fa fa-pen"></i>',
                    title: 'Toggle notes canvas (C)',
                    action: 'RevealChalkboard.toggleNotesCanvas();'
                }
            ]
        },
        // Shortcut for toggling between screen and PDF mode
        pdfExportShortcut: 'E',
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealChalkboard, RevealCustomControls, RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath.KaTeX, CopyCode, PdfExport],



    });
    Reveal.configure({
        pdfSeparateFragments: false
    });
    </script>
</body>

</html>