<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Lecture 15</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../dist/reset.css">
    <link rel="stylesheet" href="../dist/reveal.css">
    <link rel="stylesheet" href="../dist/theme/white.css" id="theme">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../plugin/highlight/github.css">
    <link rel="stylesheet" href="../plugin/chalkboard/style.css">
    <link rel="stylesheet" href="../plugin/customcontrols/style.css">
    <link rel="stylesheet" href="../plugin/menu/font-awesome/css/all.css">
</head>

<body>
    <div class="reveal" style="background-color: #fff;">
        <div class="slides">
            <section data-background-iframe="../particles/demo/index.html" style="text-align: left;">
                <div style="position: absolute; width: 60%; left: 0; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.6); color: #fff; padding: 20px; font-size: 20px; text-align: left;">
                         <h1 style="color: white">Python Programming</h1>
                <h3 style="color: white">Lecture 15 Dynamic Programming</h3>
                    </div>
            </section>
            <section>
                <section data-background="#2980b9" style="color: white">
                    <h2 style="color: white">15.1 Greedy Algorithm</h2>
                </section>
                <section>
                    <h5>Greedy Algorithm</h5>
                    <ul>
                        <li>A very simple problem-solving strategy</li>
                        <li>So-called greedy algorithms are short-sighted, in that they make each choice in isolation, doing what looks good right here, right now. In many ways, eager or impatient might be better names for them.</li>
                        <li>Example: The classroom scheduling problem</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li class="fragment">Suppose you have a classroom and want to hold as many classes here as possible. You get a list of classes.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/cs1.png" style="height: 180pt"></div>
                    <div class="fragment"><img data-src="../img/lecture18/cs2.png" style="height: 180pt"></div>
                    <ul>
                        <li class="fragment">You want to hold as many classes as possible in this classroom. How do you pick what set of classes to hold, so that you get the biggest set of classes possible?</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li class="fragment">Here's how the greedy algorithm works</li>
                        <li class="fragment">Pick the class that ends the soonest. This is the first class you'll hold in this classroom.</li>
                        <li class="fragment">Now, you have to pick a class that starts after the first class. Again, pick the class that ends the soonest. This is the second class you'll hold.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/cs3.png" style="height: 180pt"></div>
                </section>
                <section>
                    <h5>The 0-1 Knapsack Problem</h5>
                    <ul>
                        <li class="fragment">Suppose you're a greedy thief. You're in a store with a knapsack, and there are all these items you can steal. But you can only take what you can fit in your knapsack. The knapsack can hold 35 pounds.</li>
                        <li class="fragment">You're trying to maximize the value of the items you put in your knapsack. What algorithm do you use?</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/k1.png" style="height: 180pt"></div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">Your knapsack can hold 35 pounds of items. The stereo system is the most expensive, so you steal that.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/k2.png" style="height: 180pt"></div>
                    <ul>
                        <li class="fragment">If you'd picked the laptop and the guitar instead, you could have had $3,500 worth of loot!</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/k3.png" style="height: 180pt"></div>
                </section>
                <section>
                    <h5>The Set-covering Problem</h5>
                    <ul>
                        <li>Suppose you're starting a radio show. You want to reach listeners in all 50 states. You have to decide what stations to play on to reach all those listeners. It costs money to be on each station, so you're trying to minimize the number of stations you play on. You have a list of stations.</li>
                    </ul>
                    <div class="div-c">
                        <div class="fragment"><img data-src="../img/lecture18/sc1.png" style="height: 220pt"></div>
                    </div>
                    <div class="div-d">
                        <div class="fragment"><img data-src="../img/lecture18/sc2.png" style="height: 220pt"></div>
                    </div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">List every possible subset of stations. This is called the power set. There are $2^n$ possible subsets.</li>
                        <li class="fragment">From these, pick the set with the smallest number of stations that covers all 50 states.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/sc3.png" style="height: 180pt"></div>
                    <ul>
                        <li class="fragment">(Greedy) Pick the station that covers the most states that haven’t been covered yet. It's OK if the station covers some states that have been covered already.</li>
                        <li class="fragment">Repeat until all the states are covered. $O(n^2)$</li>
                    </ul>
                </section>
                <section>
                    <h5>The Traveling Salesman Problem (TSP)</h5>
                    <ul>
                        <li>Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/tsp1.png" style="height: 180pt"></div>
                    <div class="fragment"><img data-src="../img/lecture18/tsp2.png" style="height: 180pt"></div>
                </section>
                <section>
                    <ul>
                        <li>There are six total routes, two for each city you can start at.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/tsp3.png" style="height: 300pt"></div>
                    <ul>
                        <li class="fragment">How many possible routes are there for six cities? If you guessed 720, you're right. 5,040 for 7 cities, 40,320 for 8 cities.</li>
                        <li class="fragment">(Greedy) Arbitrarily pick a start city. Then, each time the salesperson has to pick the next city to visit, they pick the closest unvisited city.</li>
                    </ul>
                </section>
            </section>
            <section>
                <section data-background="#2980b9" style="color: white">
                    <h2 style="color: white">15.2 Dynamic Programming</h2>
                </section>
                <section>
                    <h5>The 0-1 Knapsack Problem</h5>
                    <ul>
                        <li class="fragment">Suppose you're a greedy thief. You're in a store with a knapsack, and there are all these items you can steal. But you can only take what you can fit in your knapsack. The knapsack can hold 35 pounds.</li>
                        <li class="fragment">You're trying to maximize the value of the items you put in your knapsack. What algorithm do you use?</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/DPX.png" style="height: 180pt"></div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">The simplest algorithm is this: you try every possible set of goods and find the set that gives you the most value. This algorithm takes $O(2^n)$ time.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/ss.png" style="height: 240pt"></div>
                </section>
                <section>
                    <h5>Dynamic Programming</h5>
                    <ul>
                        <li class="fragment">Dynamic programming starts by solving subproblems and builds up to solving the big problem.</li>
                        <li class="fragment">Every dynamic-programming algorithm starts with a grid. Here's a grid for the knapsack problem.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/DPX.png" style="height: 240pt"></div>
                    <ul>
                        <li class="fragment">At each cell, there's a simple decision: do you steal the item or not?</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li class="fragment">You have only the guitar to choose from in the first row.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/DPX.png" style="height: 150pt"></div>
                    <div class="fragment"><img data-src="../img/lecture18/dp2x.png" style="height: 240pt"></div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">At every row, you can steal the item at that row or the items in the rows above it. So you can't choose to steal the laptop right now, but you can steal the stereo and/or the guitar.</li>
                        <li class="fragment">The old max value was 1,500, but if you put the stereo in there instead, the value is 3,000!</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/DPX.png" style="height: 150pt"></div>
                    <div class="fragment"><img data-src="../img/lecture18/dp3.png" style="height: 240pt"></div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">The laptop weighs 3 lb, so it won't fit into a 1 lb or a 2 lb knapsack. The estimate for the first two cells stays at $1,500.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/DPX.png" style="height: 150pt"></div>
                    <div class="fragment"><img data-src="../img/lecture18/dp4.png" style="height: 240pt"></div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">At 4 lb, things get really interesting. This is an important part. The current estimate is 3,000. You can put the laptop in the knapsack, but it's only worth 2,000. The laptop weighs only 3 lb, so you have 1 lb free! You could put something in this 1 lb. What’s the maximum value you can fit into 1 lb of space? Well, you've been calculating it all along.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/dp5.png" style="height: 100pt"></div>
                    <div class="fragment"><img data-src="../img/lecture18/dp6.png" style="height: 240pt"></div>
                </section>
                <section>
                    <ul>
                        <li>Assume $w_{1},\,w_{2},\,\ldots ,\,w_{n},\,w$ are strictly positive integers. Define $m[i,w]$ to be the maximum value that can be attained with weight less than or equal to $w$ using items up to $i$ (first $i$ items).</li>
                        <li>We can define $m[i,w]$ recursively as follows: </li>
                        <li>
                            $m[0,\,w]=0$
                        </li>
                        <li>$m[i,\,w]=m[i-1,\,w]$ if $w_{i}>w$ (the new item > the current weight limit)</li>
                        <li>$m[i,\,w]=\max(m[i-1,\,w],\,m[i-1,w-w_{i}]+v_{i})$ if $w_{i}\leqslant w$</li>
                    </ul>
                </section>
                <section>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>

def knapsack(w,v,num,mw):
    res=[[-1 for j in range(mw+1)] for i in range(num+1)]
    for j in range(mw+1):
        res[0][j]=0
    for i in range(1,num+1):
        for j in range(1,mw+1):
            res[i][j]=res[i-1][j]
            if j>=w[i-1] and res[i][j] < res[i-1][j-w[i-1]]+v[i-1]:
                res[i][j]=res[i-1][j-w[i-1]]+v[i-1]
    return res[num][mw]
</code></pre>
                    </div>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
w=[2,2,6,5,4]
v=[6,3,5,4,6]
print(knapsack(w,v,len(w),10))
</code></pre>
                    </div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">
                            <p>What happens if you add an item?</p>
                        </li>
                    </ul>
                    <div class="div-a">
                        <div class="fragment"><img data-src="../img/lecture18/add1.png" style="height: 200pt"></div>
                    </div>
                    <div class="div-b">
                        <div class="fragment"><img data-src="../img/lecture18/add0.png" style="height: 200pt"></div>
                    </div>
                    <div class="div-c">
                        <div class="fragment"><img data-src="../img/lecture18/add2.png" style="height: 200pt"></div>
                    </div>
                    <div class="div-d">
                        <div class="fragment"><img data-src="../img/lecture18/add3.png" style="height: 200pt"></div>
                    </div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">Would the value of a column ever go down? Is this possible? <b>No</b></li>
                        <li class="fragment">What happens if you change the order of the rows? <b>The answer does not change</b></li>
                        <li class="fragment">What happens if you add a smaller item?</li>
                        <li class="fragment">Can you steal fractions of an item? <b>DP cannot solve it</b></li>
                        <li class="fragment">Dynamic programming only works when each subproblem is discrete—when it doesn't depend on other subproblems.</li>
                        <li class="fragment">The complexity of Dynamic programming is pseudo-polynomial (伪多项式时间). n(not real polynomial). An $O(nW)$ time algorithm is possible using dynamic programming; since the number $W$ only needs $log W$ bits to describe, this algorithm runs in pseudo-polynomial time.</li>
                        <li class="fragment">Example: testing whether a number n is prime</li>
                    </ul>
                </section>
            </section>
            <section>
                <section data-background="#2980b9" style="color: white">
                    <h2 style="color: white">15.3 DP: Examples</h2>
                </section>
                <section>
                    <h5>Longest Common Substring (最长公共子串)</h5>
                    <ul>
                        <li class="fragment">Dynamic programming is useful when you're trying to optimize something given a constraint. In the knapsack problem, you had to maximize the value of the goods you stole, constrained by the size of the knapsack.</li>
                        <li class="fragment">You can use dynamic programming when the problem can be broken into discrete subproblems, and they don't depend on each other.</li>
                    </ul>
                    <ul>
                        <li class="fragment">Suppose you run dictionary.com. Someone types in a word, and you give them the definition.</li>
                        <li class="fragment">But if someone misspells a word, you want to be able to guess what word they meant. Alex is searching for fish, but he accidentally put in hish. That's not a word in your dictionary, but you have a list of words that are similar.</li>
                        <li class="fragment">What substring do hish and fish have in common?</li>
                    </ul>
                </section>
                <section>
                    <h5>Making the grid</h5>
                    <ul>
                        <li class="fragment">What are the values of the cells?</li>
                        <li class="fragment">How do you divide this problem into subproblems?</li>
                        <li class="fragment">What are the axes of the grid?</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/lcs1.png" style="height: 240pt"></div>
                </section>
                <section>
                    <div class="fragment"><img data-src="../img/lecture18/lcs2.png" style="height: 400pt"></div>
                </section>
                <section>
                    <ul>
                        <li>$c(i,\,j)=c(i-1,j-1)+1$ if $x_i=y_i$</li>
                        <li>$c(i,\,j)=0$ if $i>0$ or $j>0$, $x_i!=y_i$</li>
                    </ul>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def common_substring(s1,s2):
    cell=[[] for x in range(len(s1))]
    for x in cell:
        for y in range(len(s2)):
            x.append(0)
    longest=0
    for i in range(len(s1)):
        for j in range(len(s2)):
            if i==0 or j==0:
                if s1[i]==s2[j]:
                    cell[i][j]=1
            else: 
                if s1[i]==s2[j]:
                    cell[i][j]=cell[i-1][j-1]+1
            if cell[i][j]>longest:
                longest = cell[i][j]
    return longest
</code></pre>
                    </div>
                </section>
                <section>
                    <h5>Longest Common Subsequence (最长公共子序列)</h5>
                    <ul>
                        <li class="fragment">The number of letters in a sequence that the two words have in common.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/lcss1.png" style="height: 200pt"></div>
                </section>
                <section>
                    <div class="fragment"><img data-src="../img/lecture18/lcss2.png" style="height: 400pt"></div>
                </section>
                <section>
                    <ul>
                        <li>$c(i,\,j)=c(i-1,j-1)+1$ if $x_i=y_i$</li>
                        <li>$c(i,\,j)=max(c(i-1,j),c(i,j-1))$ if $i>0$ or $j>0$, $x_i!=y_i$</li>
                    </ul>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def common_subsequence(s1,s2):
    cell=[[] for x in range(len(s1))]
    for x in cell:
        for y in range(len(s2)):
            x.append(0)
    longest=0
    for i in range(len(s1)):
        for j in range(len(s2)):
            <mark>if s1[i]==s2[j]:</mark>
                if i==0 or j==0:
                    cell[i][j]=1
                else:
                    cell[i][j]=cell[i-1][j-1]+1
            <mark>else:</mark>
                <mark>cell[i][j]=max(cell[i-1][j],cell[i][j-1])</mark>
            if cell[i][j]>longest:
                longest = cell[i][j]
    return longest
</code></pre>
                    </div>
                </section>
                <section>
                    <h5>Coin Optimization Problem</h5>
                    <ul>
                        <li class="fragment">Suppose a customer puts in a dollar bill and purchases an item for 37 cents. What is the smallest number of coins you can use to make change? (63 cents)</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/coins.jpg" style="height: 150pt"></div>
                    <ul>
                        <li class="fragment">25*2+10+1*3 (Greedy Algorithm)</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>In addition to the usual 1,5,10 and 25 cent coins they also have a 21 cent coin. In this instance our greedy algorithm fails to find the optimal solution for 63 cents in change.</li>
                        <li>The optimal answer is three 21 cent pieces.</li>
                    </ul>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
# Recursive Version of Coin Optimization Problem
def recMC(coinValueList,change):
    minCoins = change
    if change in coinValueList:
        return 1
    else:
      for i in [c for c in coinValueList if c <= change]:
        numCoins = 1 + recMC(coinValueList,change-i)
        if numCoins < minCoins:
            minCoins = numCoins
    return minCoins

print(recMC([1,5,10,25],63))
</code></pre>
                    </div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">The trouble with the algorithm is that it is extremely inefficient. In fact it takes 67716925 recursive calls to find the optimal solution to the 4 coins, 63 cents problem. The figure below illustrates a small fraction of the 377 function calls needed to find the optimal set of coins to make change for 26 cents.</li>
                        <li class="fragment"><b>The main problem is that we are re-doing too many calculations.</b> The algorithm recalculate the optimal number of coins to make change for 15 cents at least 3 times, and each of them takes 52 function calls.</li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/recMC.png" style="height: 250pt"></div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">
                            The key to cutting down on the amount of work we do is to remember some of the past results so we can avoid recomputing results we already know.
                        </li>
                        <li class="fragment">
                            A dynamic programming algorithm will take a systematic approach to the problem.
                        </li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture18/DPcoin.png" style="height: 400pt"></div>
                </section>
                <section>
                    <ul>
                        <li>$coin(change)=coin(change-i)+1$, $i\in\{coinValueList\}$</li>
                    </ul>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
# DP solution
def dpMakeChange(coinValueList,change,minCoins):
    for cents in range(change+1):
        coinCount = cents
        for j in [c for c in coinValueList if c <= cents]:
            if minCoins[cents-j] + 1 < coinCount:
                coinCount = minCoins[cents-j]+1
        minCoins[cents] = coinCount
    return minCoins[change]

print(dpMakeChange([1,5,10,25],63,{}))
</code></pre>
                    </div>
                </section>
                <section>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
# Modified DP solution
def dpMakeChange(coinValueList,change,minCoins):
    for cents in range(change+1):
        coinCount = cents
        newCoin = 1
        for j in [c for c in coinValueList if c <= cents]:
            if minCoins[cents-j] + 1 < coinCount:
                coinCount = minCoins[cents-j]+1
                newCoin = j
        minCoins[cents] = coinCount
        coinsUsed[cents] = newCoin
    return minCoins[change]
</code></pre>
                    </div>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def printCoins(coinsUsed,change):
    coin = change
    while coin > 0:
        thisCoin = coinsUsed[coin]
        print(thisCoin)
        coin = coin - thisCoin
</code></pre>
                    </div>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
coinsUsed={}
print(dpMakeChange([1,5,10,25],63,{}))
printCoins(coinsUsed, 63)
</code></pre>
                    </div>
                </section>
            </section>
            <section>
                <section data-background="#2c3e50" style="color: white; text-align: left;">
                    <h2 style="color: white">Summary</h2>
                    <ul>
                        <li>Greedy Algorithm</li>
                        <li>Dynamic Programming</li>
                    </ul>
                </section>
            </section>
        </div>
    </div>
    <script src="../dist/reveal.js"></script>
    <script src="../plugin/zoom/zoom.js"></script>
    <script src="../plugin/notes/notes.js"></script>
    <script src="../plugin/search/search.js"></script>
    <script src="../plugin/markdown/markdown.js"></script>
    <script src="../plugin/highlight/highlight.js"></script>
    <script src="../plugin/math/math.js"></script>
    <script src="../plugin/zoom_old/zoom_old.js"></script>
    <script src="../plugin/chalkboard/plugin.js"></script>
    <script src="../plugin/customcontrols/plugin.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js"></script>
    <script src="../plugin/copycode/copycode.js"></script>
    <script src="../plugin/pdfexport/pdfexport.js"></script>
    <script>
    // Also available as an ES module, see:
    // https://revealjs.com/initialization/
    Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,
        customcontrols: {
            controls: [{
                    id: 'toggle-overview',
                    title: 'Toggle overview (O)',
                    icon: '<i class="fa fa-th"></i>',
                    action: 'Reveal.toggleOverview();'
                },
                {
                    icon: '<i class="fa fa-pen-square"></i>',
                    title: 'Toggle chalkboard (B)',
                    action: 'RevealChalkboard.toggleChalkboard();'
                },
                {
                    icon: '<i class="fa fa-pen"></i>',
                    title: 'Toggle notes canvas (C)',
                    action: 'RevealChalkboard.toggleNotesCanvas();'
                }
            ]
        },
        // Shortcut for toggling between screen and PDF mode
        pdfExportShortcut: 'E',
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealChalkboard, RevealCustomControls, RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath.KaTeX, CopyCode, PdfExport],



    });
    Reveal.configure({
        pdfSeparateFragments: false
    });
    </script>
</body>

</html>