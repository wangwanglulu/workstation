<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Lecture 18</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../dist/reset.css">
    <link rel="stylesheet" href="../dist/reveal.css">
    <link rel="stylesheet" href="../dist/theme/white.css" id="theme">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../plugin/highlight/github.css">
    <link rel="stylesheet" href="../plugin/chalkboard/style.css">
    <link rel="stylesheet" href="../plugin/customcontrols/style.css">
    <link rel="stylesheet" href="../plugin/menu/font-awesome/css/all.css">
    <!-- 从Lecture10以后缩小代码字体 -->
    <link rel="stylesheet" href="../img/tinyfont.css">
</head>

<body>
    <div class="reveal" style="background-color: #fff;">
        <div class="slides">
            <section data-background-iframe="../particles/demo/index.html" style="text-align: left;">
                <div style="position: absolute; width: 60%; left: 0; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.6); color: #fff; padding: 20px; font-size: 20px; text-align: left;">
                         <h1 style="color: white">Python Programming</h1>
                <h3 style="color: white">Lecture 13 Algorithm Intro</h3>
                    </div>
            </section>
            <section>
                
                <section>
                    <div class="div-c"><img data-src="../img/lecture17/a2.jpg" style="height: 350pt"></div>
                    <div class="div-d"><img data-src="../img/lecture17/a1.png" style="height: 350pt"></div>
                </section>
                <section>
                    <ul>
                        <li>Complexity, Big-O (Searching)</li>
                        <li>Recursion, D&C</li>
                        <li>Sorting Algorithms</li>
                        <li>Greedy Algorithm</li>
                        <li>Dynamic Programming</li>
                        <li>Data Structures</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li class="fragment">
                            <p>Another stream of the basic knowledge about programming is <b>algorithm and data structure.</b></p>
                        </li>
                        <li>When two program solve the same problem but look different, is one program better than the other? (easy to read? easy to understand? execution time?)</li>
                        <li class="fragment">
                            <p>An algorithm is a set of instructions for accomplishing a task.</p>
                        </li>
                        <li class="fragment">
                            <p>Every piece of code could be called an algorithm.</p>
                        </li>
                        <li class="fragment">
                            <p>To learn this, you only need to know some basic algebra and Discrete mathematics.</p>
                        </li>
                        <li class="fragment">
                            <p>Let's start with a simple algorithm.</p>
                        </li>
                    </ul>
                </section>
                <section>
                    <h6>Binary Search</h6>
                    <ul>
                        <li class="fragment">
                            <p>Binary search is an algorithm; its input is a sorted list of elements. If an element you’re looking for is in that list, binary search returns the position where it’s located. Otherwise, binary search returns null.</p>
                        </li>
                        <li class="fragment">
                            <p>Here's an example of how binary search works. I'm thinking of a number between 1 and 100.</p>
                        </li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture17/0.png" style="height: 100pt"></div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">
                            <p>You have to try to guess my number in the fewest tries possible. With every guess, I'll tell you if your guess is too low, too high, or correct.</p>
                        </li>
                        <li class="fragment">
                            <p>Suppose you start guessing like this: 1, 2, 3, 4 ...</p>
                        </li>
                        <li class="fragment">
                            <p>If you perform a simple search, and my number was 99, it could take you 99 guesses to get there!</p>
                        </li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li class="fragment">
                            <p>Here's a better technique. Start with 50.</p>
                        </li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture17/1.png" style="height: 200pt"></div>
                    <div class="fragment"><img data-src="../img/lecture17/2.png" style="height: 200pt"></div>
                </section>
                <section>
                    <div class="fragment"><img data-src="../img/lecture17/3.png" style="height: 200pt"></div>
                    <div class="fragment"><img data-src="../img/lecture17/4.png" style="height: 100pt"></div>
                    <ul>
                        <li class="fragment">
                            <p>In general, for any list of $n$, binary search will take $log_2n$ steps to run in the worst case, whereas simple search will take $n$ steps.
                            </p>
                        </li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li class="fragment">
                            <p><b>Running time</b></p>
                        </li>
                        <li class="fragment">
                            <p>Any time I talk about an algorithm, I'll discuss its running time. Generally you want to choose the most efficient algorithm— whether you're trying to optimize for time or space.</p>
                        </li>
                        <li class="fragment">
                            <p>For simple search, the maximum number of guesses is the same as the size of the list. This is called <b>linear time</b>.</p>
                        </li>
                        <li class="fragment">
                            <p>Binary search runs in <b>logarithmic time</b>.</p>
                        </li>
                    </ul>
                </section>
                <section>
                    <h6>Big O notation</h6>
                    <ul>
                        <li class="fragment">
                            <p>Big O notation is special notation that tells you how fast an algorithm is.</p>
                        </li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture17/5.png" style="height: 120pt"></div>
                    <ul>
                        <li class="fragment">
                            <p>You need to know how the running time increases as the list size increases. That's where Big O notation comes in.</p>
                        </li>
                        <li class="fragment">
                            <p>Big O notation tells you how fast an algorithm is. For example, suppose you have a list of size n. Simple search needs to check each element, so it will take n operations. The run time in Big O notation is $O(n)$.</p>
                        </li>
                        <li class="fragment">
                            <p><b>Big O notation lets you compare the number of operations. It tells you how fast the algorithm grows. Run times grow at very different speeds.</b></p>
                        </li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li class="fragment">
                            <p>Binary search needs $log n$ operations to check a list of size n. It's $O(log n)$.</p>
                        </li>
                        <li class="fragment">
                            <p>Sometimes the performance of an algorithm depends on the exact values of the data rather than simply the size of the problem. For these kinds of algorithms we need to characterize their performance in terms of best case, <b>average case</b> and <b>worst-case</b> performance.</p>
                        </li>
                        <li class="fragment">
                            <p>$O(log n)$, $O(n)$, $O(n * log n)$, $O(n^2)$, $O(2^n)$, $O(n!)$</p>
                        </li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture17/6.png" style="height: 300pt"></div>
                </section>
                <section>
                    <h5> P, NP, NP-complete, NP-hard</h5>
                    <div class="fragment"><img data-src="../img/lecture17/66.png" style="height: 150pt"></div>
                    <ul>
                        <li class="fragment">
                            <p>P (polynomial): Problems that can be solved by polynomial time.</p>
                        </li>
                        <li class="fragment">
                            <p>NP (nondeterministic polynomial time): Decision problems for which the problem instances have proofs verifiable in polynomial time.</p>
                        </li>
                        <li class="fragment">
                            <p>NP-complete: The hardest problem in NP. Every problem can be transformed in polynomial time into it.</p>
                        </li>
                        <li class="fragment">
                            <p>NP-hard: Not NP but problems in NP can be transformed into it.</p>
                        </li>
                    </ul>
                </section>
                <section>
                    <p class="fragment">TSP (travelling salesman problem)</p>
                    <ul>
                        <li class="fragment">
                            <p>NP-hard: Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city? </p>
                        </li>
                        <li class="fragment">
                            <p>NP-complete: where given a length L, the task is to decide whether the graph has a tour of at most L.</p>
                        </li>
                    </ul>
                </section>
            </section>
            <section>
                <section data-background="#2980b9" style="color: white">
                    <h2 style="color: white">13.2 Examples</h2>
                </section>
                <section>
                    <h5>An Anagram Detection Example</h5>
                    <ul>
                        <li class="fragment"> A good example problem for showing algorithms with different orders of magnitude is the classic anagram detection prolem for strings.</li>
                        <li class="fragment"> One string is an anagram of another if the second is simply a rearrangement of the first. For example, 'heart' and 'earth' are anagrams.</li>
                    </ul>
                </section>
                <section>
                    <h5>Solution 1: Checking off</h5>
                    <ul>
                        <li class="fragment"> Check to see that each character in the first string actually occurs in the second. </li>
                    </ul>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def anagramSolution1(s1,s2):
    alist = list(s2)
    pos1 = 0
    stillOK = True

    while pos1 < len(s1) and stillOK:
        pos2 = 0
        found = False
        while pos2 < len(alist) and not found:
            if s1[pos1] == alist[pos2]:
                found = True
            else:
                pos2 = pos2 + 1

        if found:
            alist[pos2] = None  
            pos1 = pos1 + 1  
        else:
            stillOK = False
    return stillOK
</code></pre>
                    </div>
                    </ul>
                </section>
                <section>
                    <h5>Solution 2: Sort and Compare</h5>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def anagramSolution2(s1,s2):
    alist1 = list(s1)
    alist2 = list(s2)

    alist1.sort()
    alist2.sort()

    pos = 0
    matches = True

    while pos < len(s1) and matches:
        if alist1[pos]==alist2[pos]:
            pos = pos + 1
        else:
            matches = False
    return matches
</code></pre>
                    </div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">
                            <h5>Solution 3: Brute Force</h5>
                        </li>
                        <ul>
                            <li class="fragment">
                                <p>Generate a list of all possible strings using the characters from s1 and then see if s2 occurs. (Bad idea)</p>
                            </li>
                        </ul>
                        <li class="fragment">
                            <h5>Solution 4: Count and Compare</h5>
                        </li>
                        <ul>
                            <li class="fragment">
                                <p>Count the number of times each character occurs.</p>
                            </li>
                        </ul>
                    </ul>
                </section>
                <section>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def anagramSolution4(s1,s2):
    c1 = [0]*26
    c2 = [0]*26

    for i in range(len(s1)):
        pos = ord(s1[i])-ord('a') # ascii
        c1[pos] = c1[pos] + 1

    for i in range(len(s2)):
        pos = ord(s2[i])-ord('a')
        c2[pos] = c2[pos] + 1

    j = 0
    stillOK = True
    while j<26 and stillOK:
        if c1[j]==c2[j]:
            j = j + 1
        else:
            stillOK = False

    return stillOK
</code></pre>
                    </div>
                </section>
                <section>
                    <h5>Performance of Python Data Structure</h5>
                    <ul>
                        <li class="fragment">
                            <p>List</p>
                        </li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture17/list.png" style="height: 400pt"></div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">
                            <p>Dictionaries</p>
                        </li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture17/dict.png" style="height: 200pt"></div>
                </section>
            </section>
            <section>
                <section data-background="#2980b9" style="color: white">
                    <h2 style="color: white">13.3 Recursion</h2>
                </section>
                <section>
                    <h5>Recursion</h5>
                    <ul>
                        <li class="fragment">
                            <p>Recursion is a method of solving problems that involves breaking a problem down into smaller and smaller subproblems until you get to a small enough problem that it can be solved trivially. </p>
                        </li>
                        <li class="fragment">
                            <p>Recursion allows us to write elegant solutions to problems that may otherwise be very difficult to program.</p>
                        </li>
                    </ul>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def listsum(numList):
    theSum = 0
    for i in numList:
        theSum = theSum + i
    return theSum
</code></pre>
                    </div>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def listsum(numList):
   if len(numList) == 1:
        return numList[0]
   else:
        return numList[0] + listsum(numList[1:])
</code></pre>
                    </div>
                </section>
                <section>
                    <h6>Base case and recursive case</h6>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def fact(n):
    if n==1:
        return 1 #Base case
    else:
        return n * fact(n - 1) #recursive case
</code></pre>
                    </div>
                    <ul>
                        <li class="fragment">
                            <p>The recursive case is when the function calls itself. The base case is when the function does not call itself again... so it doesn't go into an infinite loop.</p>
                        </li>
                    </ul>
                </section>
                <section>
                    <h6>The stack</h6>
                    <div class="fragment">
                        <pre><code class="language-Python" data-line-numbers data-trim contenteditable>
def greet(name):
    print('hello '+ name + '!')
    greet2(name)
    print('getting ready to say bye...')
    bye()

def greet2(name):
    print('how are you, ' + name + '?')
def bye():
    print('Ok, bye!')
</code></pre>
                    </div>
                    <div class="fragment"><img data-src="../img/lecture17/s1.png" style="height: 150pt"></div>
                </section>
                <section>
                    <div class="fragment"><img data-src="../img/lecture17/s2.png" style="height: 150pt"></div>
                    <div class="fragment"><img data-src="../img/lecture17/s3.png" style="height: 150pt"></div>
                    <div class="fragment"><img data-src="../img/lecture17/s4.png" style="height: 130pt"></div>
                </section>
                <section>
                    <h6>The call stack with recursion</h6>
                    <div class="fragment"><img data-src="../img/lecture17/s5.png" style="height: 400pt"></div>
                </section>
                <section>
                    <div class="fragment"><img data-src="../img/lecture17/s6.png" style="height: 400pt"></div>
                </section>
                <section>
                    <div class="fragment"><img data-src="../img/lecture17/s7.png" style="height: 300pt"></div>
                </section>
                <section>
                    <div class="fragment"><img data-src="../img/lecture17/s8.png" style="height: 300pt"></div>
                </section>
                <section>
                    <h6>Divide and Conquer (D&C, 分而治之)</h6>
                    <ul>
                        <li class="fragment">
                            <p>D&C gives you a new way to think about solving problems. When you get a new problem, you don't have to be stumped. Instead, you can ask, "Can I solve this if I use divide and conquer?"</p>
                        </li>
                        <li class="fragment">
                            <p>You want to divide this farm evenly into square plots. You want the plots to be as big as possible.</p>
                        </li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture17/7.png" style="height: 120pt"></div>
                    <div class="fragment"><img data-src="../img/lecture17/8.png" style="height: 150pt"></div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">
                            <p>To solve a problem using D&C, there are two steps:</p>
                        </li>
                        <li class="fragment">
                            <p>1. Figure out the base case. This should be the simplest possible case.</p>
                        </li>
                        <li class="fragment">
                            <p>2. Divide or decrease your problem until it becomes the base case.</p>
                        </li>
                        <li class="fragment">
                            <p>What is the largest square size you can use? You have to reduce your problem. Let’s start by marking out the biggest boxes you can use.</p>
                        </li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture17/9.png" style="height: 200pt"></div>
                </section>
                <section>
                    <ul>
                        <li class="fragment">
                            <p>There's a farm segment left to divide. <b>Why don't you apply the same algorithm to this segment?</b></p>
                        </li>
                    </ul>
                    <div class="fragment"><img data-src="../img/lecture17/10.png" style="height: 200pt"></div>
                    <ul>
                        <li class="fragment">
                            <p>If you find the biggest box that will work for this size, that will be the biggest box that will work for the entire farm. You just reduced the problem from a 1680 × 640 farm to a 640 × 400 farm!</p>
                        </li>
                    </ul>
                </section>
                <section>
                    <div class="fragment"><img data-src="../img/lecture17/11.png" style="height: 150pt"></div>
                    <div class="fragment"><img data-src="../img/lecture17/12.png" style="height: 150pt"></div>
                    <div class="fragment"><img data-src="../img/lecture17/13.png" style="height: 150pt"></div>
                </section>
                <section>
                    <div class="fragment"><img data-src="../img/lecture17/14.png" style="height: 150pt"></div>
                    <ul>
                        <li class="fragment">
                            <p>To recap, here's how D&C works: </p>
                        </li>
                        <li class="fragment">
                            <p>1. Figure out a simple case as the base case. </p>
                        </li>
                        <li class="fragment">
                            <p>2. Figure out how to reduce your problem and get to the base case. </p>
                        </li>
                        <li class="fragment">
                            <p><b>D&C isn't a simple algorithm that you can apply to a problem. Instead, it's a way to think about a problem.</b></p>
                        </li>
                    </ul>
                </section>
            </section>
            <section>
                <section data-background="#2c3e50" style="color: white; text-align: left;">
                    <h2 style="color: white">Summary</h2>
                    <ul>
                        <li>Algorithm Intro</li>
                    </ul>
                </section>
            </section>
        </div>
    </div>
    <script src="../dist/reveal.js"></script>
    <script src="../plugin/zoom/zoom.js"></script>
    <script src="../plugin/notes/notes.js"></script>
    <script src="../plugin/search/search.js"></script>
    <script src="../plugin/markdown/markdown.js"></script>
    <script src="../plugin/highlight/highlight.js"></script>
    <script src="../plugin/math/math.js"></script>
    <script src="../plugin/zoom_old/zoom_old.js"></script>
    <script src="../plugin/chalkboard/plugin.js"></script>
    <script src="../plugin/customcontrols/plugin.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js"></script>
    <script src="../plugin/copycode/copycode.js"></script>
    <script src="../plugin/pdfexport/pdfexport.js"></script>
    <script>
    // Also available as an ES module, see:
    // https://revealjs.com/initialization/
    Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,
        customcontrols: {
            controls: [{
                    id: 'toggle-overview',
                    title: 'Toggle overview (O)',
                    icon: '<i class="fa fa-th"></i>',
                    action: 'Reveal.toggleOverview();'
                },
                {
                    icon: '<i class="fa fa-pen-square"></i>',
                    title: 'Toggle chalkboard (B)',
                    action: 'RevealChalkboard.toggleChalkboard();'
                },
                {
                    icon: '<i class="fa fa-pen"></i>',
                    title: 'Toggle notes canvas (C)',
                    action: 'RevealChalkboard.toggleNotesCanvas();'
                }
            ]
        },
        // Shortcut for toggling between screen and PDF mode
        pdfExportShortcut: 'E',
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealChalkboard, RevealCustomControls, RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath.KaTeX, CopyCode, PdfExport],



    });
    Reveal.configure({
        pdfSeparateFragments: false
    });
    </script>
</body>

</html>